---
title: JVM 메모리 분석
date: '2024-03-11'
tags: ['jvm', 'heap-memory', 'native-memory-tracking']
draft: false
---

# 지속적으로 증가하는 RSS Memory
<Image src="/static/jvm-heap-memory/rss_memory.png" alt="rss memory" />

데이터독으로 리소스 사용량을 모니터링하던 중 특정 EC2 인스턴스의 RSS 메모리가 지속적으로 증가하는 것을 발견하였다. (RSS 메모리는 Resident Set Size의 약자로, 프로세스가 사용하는 물리적 메모리의 양을 의미한다.)
그런데 여기서 이상하다고 생각한 점은 바로 비교적 트래픽이 낮은 시점에도 유지되거나 증가하는 것이었다.

나는 분명 GC가 사용하지 않는 메모리를 해제하여 총 메모리 사용량이 줄어야 한다고 생각했는데, 이 상황에서는 그렇지 않아보였다.
이번 포스팅은 어떤 근거로 이러한 현상이 일어나는지 알아보기 위해 열심히 삽질한 경험의 기록이다.

사내 개발팀은 모니터링 툴로 데이터독을 사용한다. 데이터독의 힙 메모리 메트릭을 확인했더니 다음과 같았다.

<Image src="/static/jvm-heap-memory/heap_memory.png" alt="heap memory" />

꾸준하게 증가하는 RSS 메모리와는 다르게 힙 메모리는 정상적인(?) 패턴을 갖고 있었다. 따라서 GC는 내 예상대로 잘 동작을 하고 있으니, RSS 메모리의 지속적인 증가는 GC의 문제가 아닌 다른 문제가 있을 것이라고 생각했다.

그럼 힙 메모리를 제외한 나머지 메모리는 도대체 어디서 점유되고 있는걸까. 구글링을 통해 다른 개발자분들의 경험을 참고해 볼 수 있었고, 이 중에서 나의 상황과 굉장히 비슷한 현상을 겪은 분을 보았다.
- 동일하게 힙 메모리는 사용 패턴은 정상이지만, 그 외에 네이티브 메모리가 너무 많이 사용되고 있어 프로세스의 메모리 점유율이 너무 높아짐

우선 나도 점유하고 있는 메모리가 예상했던 것보다 너무 많고, 또 지속적으로 증가하는 상황이며 힙 메모리의 사용 패턴은 정상적이었기에 네이티브 메모리 사용량을 추적해보기로 했다.

# JVM의 Native Memory를 추적하자

JVM에는 네이티브 메모리 사용량을 추적할 수 있는 기능이 있다. Java 애플리케이션 구동 시 `-XX:NativeMemoryTracking=detail` 옵션을 추가하면 네이티브 메모리 사용량을 추적할 수 있다.

```shell
$ sudo jcmd <PID> VM.native_memory detail | head -n 100
```

위의 명령어를 실행하여 메모리 사용량을 확인하니 결과는 다음과 같았다.


```shell
<PID>:

Native Memory Tracking:

Total: reserved=21428856KB, committed=11072724KB
-                 Java Heap (reserved=18874368KB, committed=10018816KB)
                            (mmap: reserved=18874368KB, committed=10018816KB)

-                     Class (reserved=1194146KB, committed=162922KB)
                            (classes #24978)
                            (malloc=6306KB #81320)
                            (mmap: reserved=1187840KB, committed=156616KB)

-                    Thread (reserved=118639KB, committed=118639KB)
                            (thread #116)
                            (stack: reserved=118108KB, committed=118108KB)
                            (malloc=399KB #679)
                            (arena=132KB #227)

-                      Code (reserved=274906KB, committed=171038KB)
                            (malloc=25306KB #32945)
                            (mmap: reserved=249600KB, committed=145732KB)

-                        GC (reserved=782599KB, committed=453975KB)
                            (malloc=49415KB #87100)
                            (mmap: reserved=733184KB, committed=404560KB)

-                  Compiler (reserved=444KB, committed=444KB)
                            (malloc=310KB #2523)
                            (arena=135KB #7)

-                  Internal (reserved=90456KB, committed=90456KB)
                            (malloc=90424KB #76509)
                            (mmap: reserved=32KB, committed=32KB)

-                    Symbol (reserved=30833KB, committed=30833KB)
                            (malloc=26191KB #265835)
                            (arena=4643KB #1)

-    Native Memory Tracking (reserved=9375KB, committed=9375KB)
                            (malloc=662KB #9487)
                            (tracking overhead=8712KB)

-               Arena Chunk (reserved=199KB, committed=199KB)
                            (malloc=199KB)

-                   Tracing (reserved=16025KB, committed=16025KB)
                            (malloc=16025KB #804)

-                   Unknown (reserved=36864KB, committed=0KB)
                            (mmap: reserved=36864KB, committed=0KB)
...
```

위의 결과를 보면 Total committed가 11GB, Java Heap이 10GB로 대부분을 차지하고 있음을 알 수 있다.
이 결과를 통해 알 수 있는 것은, 앞서 참고했던 블로그의 상황과는 조금 다르게 네이티브 메모리가 많이 사용되는 것이 아닌 그저 Java 힙 메모리가 많이 할당된 것이다.

# Committed와 Used의 차이

분명 데이터독의 힙 메모리 사용량 메트릭을 봤을 때는 10GB까지 보이지 않았는데, `Committed`와는 어떤 차이가 있길래 이런 결과가 나왔는지 알아보았고, 다음과 같은 결론을 얻었다.

- Committed: JVM이 OS에 요청한 메모리의 양
- Used: JVM이 실제로 사용하고 있는 메모리의 양

즉 `Committed`는 JVM이 OS에 요청하여 점유하고 있는 메모리 양이며, `Used`는 점유하고 있는 메모리 중 실제로 사용되고 있는 메모리 양이다.

Java 애플리케이션 실행 시 추가한 `Xmx`의 설정값까지 Java 힙의 `Committed`가 증가할 수 있고, JVM은 `Committed` 안에서 메모리를 사용할 수 있다. 따라서 `Committed`는 `Used`보다 항상 크거나 같다.
그렇기 때문에 RSS 메모리가 증가하는 것은 내가 설정한 `Xmx` 값까지 `Committed`가 증가하면서 발생하는 것이다.

또한 사용중인 힙 메모리 메트릭은 줄어들더라도, RSS 메모리는 줄어들지 않는 이유도 여기에 있다.
OS에 요청하여 한번 점유하기 시작한 메모리는 JVM이 프로세스를 안정적으로 관리하기 위해 굉장히 보수적으로 관리하게 된다.
따라서 사용하고 있는 메모리가 줄어든다고 해서 무조건 OS로 반납하는 것은 아니다.

그렇다고 `Committed`가 아예 줄어들지 않는 것은 아니다. 자세한 것은 GC에 대해 깊게 공부한 이후에 설명할 수 있겠지만, 확실한 것은 `Committed` 또한 GC의 영향으로 줄어들 수도 있다는 것이다.
`jcmd`의 `GC.run` 커맨드를 수동으로 실행했을 때 실제로 메모리 사용량이 줄어드는 것을 확인했다.

# 마무리

Java 애플리케이션이 점유하고 있는 메모리가 너무 많은 경우 NativeMemoryTracking을 통해 메모리를 분석하면 다양한 정보를 얻어 원인을 쉽게 파악할 수 있다.

만약 위와 같이 현재 사용중인 힙 메모리양은 별로 높지 않은데 점유하고 있는 메모리가 너무 높아 NMT를 진행한다면 다음과 같은 점을 확인하면 좋다.
- 점유하고 있는 메모리를 전부 JVM 추적하고 있는지 확인, 아니라면 이 포스팅의 상황과는 다르게 힙, 네이티브 영역이 아닌 다른 곳에서 메모리를 점유하고 있는 것.
  - 이런 경우 아래의 기술 블로그를 참조하면 좋을 것 같다. 나 또한 해당 포스팅을 참고하여 NMT를 진행했다.
  - [Java Process 메모리 추적기 - Whatap 기술 블로그](https://www.whatap.io/ko/blog/57/)
- Java 프로세스 실행 시 명시적으로 Xmx를 설정했는지 확인, 설정하지 않았다면 JVM default 값으로 설정되어 있을테니 확인해 볼 것. 만약 설정이 되어있다면 실제로 사용하는 힙 메모리에 비해 너무 높게 설정된 것은 아닌지 모니터링 해야 함.
